####为什么java 可以一次编译到处运行

- 我们首先使用javac将源文件(.java)编译成字节码(.calss)，这时候的字节码是统一的
- 不同系统中jvm的解释器是不同的
- 解释器将我们相同的字节码编译成不同系统的机器码
- 从而实现一次编译到处运行

![image-20200220100622497](C:/Users/16781/AppData/Roaming/Typora/typora-user-images/image-20200220100622497.png)

####jvm虚拟机有什么，他们是线程是私有还是公有的

- 线程私有（生命周期和线程相同）
  - 虚拟机栈：是方法执行的内存模型对应着一个栈帧入栈到出栈的过程，每一个方法执行的同时都会创建一个栈，用来存放**局部变量表，操作数栈，动态链接（属性在堆中的引用），方法返回值**，
  - 本地方法栈：类似于虚拟机栈，只不过是本地方法执行
  - pc计数器：是当前线程所执行的字节码的行号指示器
- 线程公有（生命周期和jvm有关）
  - 堆
  - 方法区
- 类加载机制
- 执行引擎
  - 编译器
  - 垃圾回收机制

#### 栈里面有哪些数据，他的一些特性是什么

- 栈的生命周期跟随线程的生命周期，他是线程私有的
- 每一个方法是一个栈帧，栈帧中包含局部变量，操作数栈，动态链接引用，方法返回值
- 栈遵循后进先出原则
- 会触发异常 java.lang.StackOverflowError

#### 什么时候会出现栈异常，怎么处理

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverFlowError异常；
- 如果虚拟机在扩展栈内存时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。
- 例子
  - 当我们**递归调用**方法的时候，因为一直在进行压栈不进行释放，会达到最大深度从而异常
  - 当我们**局部变量较大**的时候会出现异常，因为局部变量保存在栈当中，所以不应该太过大
- 解决办法
  - 优化递归方法
  - 将局部变量变小，改用动态分配，使用堆而非是栈
  - 增加栈的大小(-Xss)，stack默认大小是1m



#### 堆是什么，堆里有哪些信息

- 堆是我们用来存放我们所创建的对象和数组的一块内存区域，
- 他是线程共享的
- 采用了分带收集算法因此他里面还问为新生代和老年代



#### 永久代/元空间存放的那些信息，他们的区别是什么，为什么要使用元空间

- 他们两个都是方法区的实现，方法区是java的规范，永久代/元空间是对规范的落地实现
- 方法区中 存储被 JVM 加载的**类信息、常量、静态变量、即时编译器编译后的代码**等数据. 
- 运行常量池是方法区的一部分，除了包括类的基本信息(类的版本、字段、方法、接口等信息)还有**常量池**信息
- 常量池在1.7之后从方法区转移到堆中
- 永久代
  - 在虚拟机开辟的内存空间
  - 在内存不够的时候会触发oom异常
- 元空间
  - 在本地开辟的内存空间，默认情况下，元空间的大小仅受本地内存限制
  - 在本地不会出现oom异常，但是采用的组块分配的形式，所以导致碎片的产生
    - -XX:MetaspaceSize，初始空间大小，
    - -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
    - -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比
    - -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比
- 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出,所以转变为元空间



#### jvm是如何确定哪些是垃圾需要回收的，GC root是什么

- 引用计数算法
  - 如果一个对象没有和任何有关联，他的引用计数为0，那么这个对象可回收
- 可达性算法
  - 解决引用计数法的循环引用，即两个对象相互引用，导致引用计数不为零，无法被回收
  - 通过一系列的GC roots（根集合）来向下搜索，如果一个对象和根集合没有一个可达性路径，那么这个对象有为不可达的，
  - 那些可以当做GC roots？
    - 虚拟机栈中引用的对象； （方法中new的对象）
    - 方法区中类静态属性引用的对象； （static a = new A（））
    - 方法区中的常量引用的对象； 
    - 本地方法栈中JNI（即一般说的Native方法）的引用的对象；



#### 你都知道那些gc回收算法

- 标记清除法

  - 首先将标记需要回收的对象
  - 然后进行清除
  - 会出现内存碎片化

- 复制算法

  - 首先将我们的内存区域分为两半，每次只是用其中的一半
  - 标记需要回收的对象，将存活对象移动到另外一半没被使用的内存区域
  - 清除需要回收的对象

- 标记清除整理法

  - 标记需要回收的对象
  - 将存活对象移动到内存的一端
  - 清除存活对象边界外的对象

- 分代收集算法

  - 将堆分为了新生代和老年代，新生代一般占据堆的1/3空间

  - 新生代又分为Eden区和ServivorFrom ，ServivorTo ， 默认的，Edem : from : to = 8 :1 : 1



#### 目前有哪些收集器，我们现在使用的是那种

- **新生代（复制算法），垃圾较多**
  - Serial 垃圾回收器
    - 新生代的单线程回收，
    - 进行垃圾回收的时候，工作线程需要停止，直到垃圾回收完成
  - ParNew 垃圾回收器
    - serial＋多线程，多线程的serial版本
    - 进行垃圾回收也会停止线程
    - 默认开启和cpu相同的线程数
    - 通过参数-XX:ParallelGCThreads  来改变线程数
  - Parallel Scavenge 收集器
    - 多线程垃圾回收器
    - 关注是程序达到一个可控制的吞吐量
    - 自适应调节是他和parnew的一个重要区别
- **老年代（标记-整理算法），垃圾比较少**
  -  Serial Old 收集器
    - 他是serial的老年代收集器版本，单线程，也会停止线程直到回收完毕
    - 他可以和新生代的三种收集器任意搭配使用
    - 他还是CMS的后备垃圾回收方案
  - Parallel  old 收集器
    - 他对应的是Parallel Scavenge收集器，关注老年代吞吐量
    - 多线程垃圾回收器
    - 他只能搭配parallel scavenge使用，关注吞吐量优先使用此搭配
  -  CMS
    - 使用了标记-清除算法，**缩短了垃圾收集线程暂停时间**可以为交互比较高的程序提高用户体验
      1. **暂停**线程标记gcroot 可以直接关联的对象
      2. **并发**标记gcroot向下跟踪
      3. **暂停**线程修改变动过的标记
      4. **并发**清理
    - 缺点
      - 碎片化：因为使用的是标记-清理算法
      - 占用cpu资源：线程使用过多
      - 浮动垃圾：因为并发清理，所以此阶段用户有可能产生新的垃圾无法被标记，只能等待下一次
  - G1收集器
    - 他是基于标记-整理算法的，不产生碎片
    - 打破了新生代和老年代的物理隔离，将整个堆分割成多个固定大小的块，也就是region
    - 每region都有不同的标记：eden，survivor和old
- 默认使用和总结
  - 通过命令查看默认收集器java -XX:+PrintCommandLineFlags -version
  - 默认使用ParallelGC收集器，也就是在新生代使用Parallel Scavenge收集器，老年代使用ParallelOld收集器

<img src="C:/Users/16781/AppData/Roaming/Typora/typora-user-images/image-20200227110031674.png" alt="image-20200227110031674" style="zoom:50%;" />





#### 都有哪些引用

- 强引用
  - 当一个对象被强引用的时候，他是可达的，不可能被回收，也是导致内存泄露的原因
- 软引用
  - 内存足够不会被回收，内存不够时被回收
- 弱引用
  - 只要运行垃圾回收，不管内存是否足够，均被回收
- 虚引用
  - 和没有被引用一样，无法单独使用



#### 说一下新生代是如何运用复制算法的

1. 当发生GC的时候，我们会将Eden和from区存活的对象复制到to区
2. 清除Eden和from的对象
3. to区变成from
4. Eden和from继续分配新生对象



#### 什么时候是MajorGC，MinorGC和full GC，什么情况下触发

- **MinorGC**：新生代
  - 当新生代无法为新对象分配内存空间的时候触发MinorGC
  - Eden区满了触发GC
  - 对象每熬过一次GC，年龄+1，默认年龄到达15的时候进入老年代

- **MajorGC**：老年代
  - 当老年代不够用触发MajorGC

- **fullGc**是整个堆空间—包括年轻代和永久代
  - 调用system.gc，建议执行Full GC，但是不一定执行
  - 老年代不足
  - 方法区不足
  - 通过youngGC的对象大于老年代可用内存
  - 对象大于to区的内存，而且老年代内存也小于这个对象



#### 内存溢出和内存泄露

- 内存溢出
  - 当内存用完的时候，无法分配内存会出现内存溢出
- 内存泄露
  - 当对象没有被引用后无法被回收导致导致出现内存泄露
  - 长期的内存泄露会导致内存溢出





#### 如何查看gc日志

#### jvm会出现哪些异常

- 栈
  - java.lang.StackOverFlow.Error 
- 堆
  - java.lang.OutOfMemoryError:java heap speace 
  - java.lang.OUtOfMemory Error
- 方法区
  - java.lang.OutOfMemoryError: PermGen speace

#### 怎么排查异常

- 栈
  - 先排查是否有递归或较大的变量
  - 加大-Xss参数，增大栈内存
  - 减少线程
- 堆
  - 查看是否是内存泄露
  - 增大初始内存和最大内存-Xms，-Xmx



#### jvm的类加载机制

- 加载
  - 创建字节流去读取.class二进制文件，并产生对象
- 验证
  - 验证加载进来的文件是否符合jvm规范
  - 文件格式的验证
  - 元数据的验证
  - 字节码验证
  - 符号引用验证
- 准备
  - 为静态变量分配内存，进行初始化
- 解析
  - 将常量池的符号引用转变为直接饮用
- 初始化
  - 初始化父类再初始化子类



#### jvm的类加载器都有哪些

- Boostrap（根类加载器）,它用来加载 Java 的核心库，是用原生代码来实现的
- Extension（扩展类加载器），它用来加载 Java 的扩展库。
- System（系统，应用类加载器） ，它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类
- 类加载器需要保证类装载过程的线程安全-装载一个不存在的类的时候，因为采用的双亲加载模式，所以强制加载会直接报错



#### 什么是双亲委派模型

- 双亲委派模型  这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都是用组合关系来复用父加载器的代码。
- 当一个类收到类加载请求的时候，自己不去加载这个请求，而是将这个类的请求委派给父类加载器，直到传递给启动类加载器，只有当父加载器无法加载这个请求的时候，子加载器才会自己加载，
- 双亲委派机制的最大优点就是使得java类随着它的类加载器一起具备了一种带有优先级的层次关系。尤其是保证了基础类的统一性，保证了java程序的稳定运行。



#### jvm的调优一些参数

```shell
  # 配置最大内存和初始内存
    -Xms #起始内存
    -Xmx #最大内存
    -Xmn #新生代内存
    -Xss #栈大小。 就是创建线程后，分配给每一个线程的内存大小
    
    #设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
    -XX:NewRatio=n
    
    #年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
    -XX:SurvivorRatio=n
    
    -XX:MaxPermSize=n#设置持久代大小
    #收集器设置
    -XX:+UseSerialGC#设置串行收集器
    -XX:+UseParallelGC#设置并行收集器
    -XX:+UseParalledlOldGC#设置并行年老代收集器
    -XX:+UseConcMarkSweepGC#设置并发收集器
    #垃圾回收统计信息
    -XX:+PrintGC
    -XX:+PrintGCDetails
    -XX:+PrintGCTimeStamps
    -Xloggc:filename
    #并行收集器设置
    -XX:ParallelGCThreads=n  #设置并行收集器收集时使用的CPU数。并行收集线程数。
    -XX:MaxGCPauseMillis=n  #设置并行收集最大暂停时间
    -XX:GCTimeRatio=n # 设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
    #并发收集器设置
    -XX:+CMSIncrementalMode#设置为增量模式。适用于单CPU情况。
    -XX:ParallelGCThreads=n#设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。
```

