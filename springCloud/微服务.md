#### 微服务 微服务架构  springcloud的区别

- 微服务
  - 强调的是服务大小
- 微服务架构
  - 一种架构模式，
  - 将单一的应用拆分成一组小的服务，服务之间互相协调配合，
  - 每个服务运行在独立的进程中
  - 服务之间采用轻量级的通信机制相互沟通
  - 围绕业务构建，可单独的部署
  - 可以使用不同语言或攻击进行微服务开发
  - 可以使用不同的数据库进行存储
- springcloud
  - 微服务架构下的一站式解决方案
  - 包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件
  - 包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话



#### 为什么要使用微服务，优点是什么

- 微服务可能只干一件事，职责专一
- 松耦合，可以被单独开发和部署
- 微服务不与前端混合
- 可以有自己独立的数据库





####dubbo和springcloud的区别，和你的选型

- dubbo
  - 通信使用的是RPC
  - 定位是RPC框架
  - 基于二进制
  - 开发难度较大，jar包依赖较强
- springcloud
  - 通信采用HTTP的REST方式
  - 定位是一站式解决方案
  - 基于http协议



#### RPC和REST的区别

- rpc
  - 远程方法调用，像调用本地方法一样调用远程服务器方法
  - 性能好，底层基于tcp/ip协议在传输层进行传输
  - 大致过程是客户端调用服务，客户端stub序列化，找到服务地址，服务端stub反序列化，调用服务器服务，本地执行完方法，返回结果，服务端stub序列化，发送给消费方，消费方反序列化
  - RPC框架一般用在自家系统内部，不对外的接口使用
- rest
  - 基于http协议的一组约束和属性
  - 无状态：不将用户的状态（信息）保存在服务器上，而是保存在客户端上，比如说我们不讲登录信息保存在session中，而是保存在token中
  - 对外开放的接口使用rest比较好
  - http在应用层
  - 比较灵活
  - 相对rpc性能比较低



#### 微服务之间是如何独立通讯的

同步：RPC或者RESST

异步：消息队列



#### 你所知道的微服务技术栈有哪些？请列举一二

- 服务注册与发现
  - Eureka，Consul，Zookeeper，Nacos
- 服务调用
  - ribbon，feign，openfeign
- 服务降级
  - Hystrix
- 服务网关
  - zuul，gataway
- 服务配置
  - config，nacos
- 服务总线
  - bus，nacos



#### Eureka是什么

基于REST的服务注册中心，主要用来主管服务注册和发现，类似于zookepper，采用了c-s的设计架构。





####Eureka和zookeeper的区别

- Eureka
  - 保证的是AP原则，即高可用性，分区容错性
  - 各个节点都是相等的，当其中一台宕机之后，剩余的节点依然可以提供注册和查询服务，保证了可用性，只不过有可能查询到信息不是最新的，
  - 独有的自我保护机制
- Zookeeper
  - 保证的是CP原则，即强一致性，分区容错性
  - 当主机宕机之后，其他节点要重新进行选举，这段时间较长，导致服务在这段时间无法使用



####Eureka的自我保护机制是什么

某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存

`Eureka Client` 从server端获取注册表信息缓存在本地，并每30秒来发送一次心跳来更新实例信息。通知`Eureka Server`该实例仍然存在。如果超过90秒没有发送更新，则服务器将从注册信息中将此服务移除。



####Eureka如何搭建



#### dependencymanagement和dependency的区别

- dependency
  - 子类项目全部继承父类dependency里的所有依赖
- dependencymanagement
  - 声明式依赖，子类必须显示的声明所需要的依赖,否则不会从父类继承
  - 如果子类声明了该依赖，没有写版本号，会从父类依赖
  - 如果写了版本号，则使用子类自定义的版本号





#### consul

和zk的注册类似、

首先pom文件引入依赖

yml编写端口号注册

主启动类加上注解



#### jemeter 压力测试器



#### Ribbon

客户端负载均衡的工具，Ribbon+RestTemplate



#### Ribbon和nginx的区别



#### Ribbon的负载算法



####openfeign的用法

只需绑定服务接口，即可实现负载均衡



#### Hystrix

用于处理分布式系统的延迟和容错的开源库，在分布式系统中，避免不了超时和异常，这时候为了避免整体服务的失败和连级故障采用Hystrix的降级和熔断来提高分布式系统的弹性



#### Hystrix的使用

第一种自我使用配置

- pom文件引入 spring-cloud-starter-netflix-hystrix
- 启动类标注@EnableCircuitBreaker/EnableHystrix,第二个包含了第一个
- 降级方法标注@HystrixCommand(fallbackMethod = "login1")



第二种feign搭配使用hystrix（客户端）

- pom文件引入	

- yml文件开启feign使用hystrix，默认是关闭的

  ```shell
  #打开基于feign的hystrix
  feign:
    hystrix:
      enabled: true
  ```

- 启动类标注注解@EnableHystrix

- 本地时间接口的实体类作为降级后的兜底方法

- 在接口上的@FeignClient中表明降级去找我们所实现的类

  ```java
  @FeignClient(value = "PROVIDER",fallback = HelloOpenFeignServiceImpl.class)
  public interface HelloOpenFeignService {
  ```



#### 降级和熔断的区别

**服务降级 ** 

考虑服务器整体负荷，在整体压力较大，资源不够用的情况下，对某些不重要的服务进行降级，也就是执行备选方案，来减轻服务器整体压力，来保证其他重要业务服务的正常运行

**服务熔断**  

服务下游的服务发生了故障，为了防止整条链路全部崩溃，采取的保护措施，

在一定时间内达到自己设好的阙值时，比如在规定时间内多少次访问失败率达到多少开启熔断，对服务开启熔断，然后对其进行降级使用其他方法，并过一段时间之后，再次进行对原服务尝试请求，如果请求成功则恢复使用

**相同点**：

- 目的相同，都是为了保证服务的高可用
- 结果相同，用户体验到的是某些功能暂不可用

**不同点**：

- 出发点不同，降级是舍弃不重要的来保护全部，熔断是自身达到临界点对自身的保护
- 层次，降级可以分为层级进行降级，可以一层一层的开始将



#### hystrix流程： 

请求进来后 先查看熔断是否打开，熔断打开直接进入降级的备选方法，熔断未打开进入方法执行操作，方法操作失败，超时， 会记录到熔断器，并且进行降级，完全成功才可返回数据，如果达到熔断器的触发条件，则开启熔断，并保持一段时间，之后再次让尝试请求看是否能成功访问，如果可以则熔断器关闭





####为什么使用网关

路由转发 + 过滤器，可以实现负载和进行安全过滤和身份验证



#### gateway和zuul的区别

- zuul
  - 基于阻塞io的模型
  - 仅支持同步
- gateway
  - 非阻塞web框架
  - 支持异步



pom文件添加依赖

gateway的配置  

yml文件配置动态路由

````yml
spring:
 cloud:
  gateway:
   discovery:
    locator:
     enable:true #开启从注册中心创建动态路由，利用微服务进行动态路由
   routes:
    -id: #唯一id，建议配合服务名
    uri:CLOUD-SERVICE #提供服务的路由地址
    predicates: 
     -Path=/hello/login #断言，路径匹配
			 
````



#### serverconfig 中心化配置

将所有公用的配置提取到config中心，然后通过github来动态的更新配置文件的消息，不用再去重启服务，实现热更新配置文件



#### 使用

配置服务器

配置客户端

服务器连接的是github

客户端连接服务端

github更改 --- 服务端更改----发送请求让客户端自动刷新





#### bus 消息总线

在更改中心配置文件后，还需要手动的请求每一个客户端刷新，比较麻烦，而使用消息总线，可以使所有订阅了消息的服务进行自动刷新，只需要给config中心下发刷新指令即可



####使用

只能配合rabbitmq和kafka一起使用

首先在客户端和服务端加载pom依赖

在yml配置文件添加mq的配置信息和暴露信息

修改github文件的时候，在用命令进行单点通知或者是全部通知